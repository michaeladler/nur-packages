From 086ac7846c1c77e788bb5fc12a3727cf9d172c2a Mon Sep 17 00:00:00 2001
From: Michael Adler <adlerm@mailbox.org>
Date: Sun, 26 Mar 2023 14:52:54 +0200
Subject: [PATCH] fix: only watch directories known to git

gitui crashes if it encounters a directory which it is not allowed to
enter (due to permissions). Also, gitui doesn't respect gitignore when
setting up the file watches which can result in a very expensive
operation for huge file trees.
---
 src/watcher.rs | 35 ++++++++++++++++++++++++++---------
 1 file changed, 26 insertions(+), 9 deletions(-)

diff --git a/src/watcher.rs b/src/watcher.rs
index ee0c3aa..38a3d4f 100644
--- a/src/watcher.rs
+++ b/src/watcher.rs
@@ -1,4 +1,5 @@
 use anyhow::Result;
+use asyncgit::sync::{tree_files, utils, RepoPath};
 use crossbeam_channel::{unbounded, Sender};
 use notify::{
 	Config, Error, PollWatcher, RecommendedWatcher, RecursiveMode,
@@ -8,7 +9,12 @@ use notify_debouncer_mini::{
 	new_debouncer, new_debouncer_opt, DebouncedEvent,
 };
 use scopetime::scope_time;
-use std::{path::Path, thread, time::Duration};
+use std::{
+	collections::HashSet,
+	path::{Path, PathBuf},
+	thread,
+	time::Duration,
+};
 
 pub struct RepoWatcher {
 	receiver: crossbeam_channel::Receiver<()>,
@@ -81,6 +87,12 @@ fn create_watcher(
 ) {
 	scope_time!("create_watcher");
 
+	let repo_path = RepoPath::Path(PathBuf::from(workdir));
+	let commit = utils::get_head(&repo_path).unwrap();
+	let files = tree_files(&repo_path, commit).unwrap();
+	let dirs: HashSet<&Path> =
+		files.iter().filter_map(|f| f.path.parent()).collect();
+
 	if poll {
 		let config = Config::default()
 			.with_poll_interval(Duration::from_secs(2));
@@ -88,19 +100,24 @@ fn create_watcher(
 			timeout, None, tx, config,
 		)
 		.expect("Watch create error");
-		bouncer
-			.watcher()
-			.watch(Path::new(&workdir), RecursiveMode::Recursive)
-			.expect("Watch error");
+
+		let watcher = bouncer.watcher();
+		for dir in dirs {
+			watcher
+				.watch(dir, RecursiveMode::NonRecursive)
+				.expect("Watch error");
+		}
 
 		std::mem::forget(bouncer);
 	} else {
 		let mut bouncer = new_debouncer(timeout, None, tx)
 			.expect("Watch create error");
-		bouncer
-			.watcher()
-			.watch(Path::new(&workdir), RecursiveMode::Recursive)
-			.expect("Watch error");
+		let watcher = bouncer.watcher();
+		for dir in dirs {
+			watcher
+				.watch(dir, RecursiveMode::NonRecursive)
+				.expect("Watch error");
+		}
 
 		std::mem::forget(bouncer);
 	};
-- 
2.39.2

